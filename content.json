{"meta":{"title":"周璇的个人博客","subtitle":null,"description":"在每个银河坠入山谷的梦里，我会醒来，也忘记梦境...","author":"zhou xuan","url":"https://zhouxuan001.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-07-25T09:37:08.374Z","updated":"2019-07-25T09:37:08.374Z","comments":false,"path":"/404.html","permalink":"https://zhouxuan001.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-07-25T09:37:08.380Z","updated":"2019-07-25T09:37:08.380Z","comments":false,"path":"about/index.html","permalink":"https://zhouxuan001.github.io/about/index.html","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132&#123; name: &apos;cofess&apos; age: 22, gender: &apos;男&apos;, profession: &apos;Web Developer &amp; Internet&apos;, experience: &apos;2年&apos;, address: &apos;广东省深圳市&apos;, education: &apos;本科&apos;, github: &apos;https://github.com/zhouxuan001&apos;, blog: &apos;https://zhouxuan001.github.io&apos;, email: &apos;906085013@qq.com&apos;, description: &apos;致力于网站建设与前端用户体验设计&apos;, skills: [ [&apos;Html&apos;, &apos;Javascript&apos;, &apos;jQuery&apos;, &apos;CSS&apos;, &apos;ES6&apos;, &apos;Node&apos;], [&apos;Webpack&apos;, &apos;Gulp&apos;], [&apos;Less&apos;,&apos;Sass&apos;], [&apos;Git&apos;, &apos;SVN&apos;], [&apos;Vue&apos;], [&apos;Bootstrap&apos; , &apos;Angular&apos; ], [&apos;微信小程序&apos;] ], devTools: [ [&apos;Sublime Text&apos;, &apos;Hbuild&apos;, &apos;Notepad++&apos;, &apos;Eclipse&apos;], [&apos;Photoshop&apos;], [&apos;Chrome DevTools&apos;, &apos;IETester&apos;], [&apos;TortoiseSVN&apos;, &apos;TortoiseGit&apos;], [&apos;Beyond Compare&apos;, &apos;FlashFXP&apos;], [&apos;Navicat&apos;, &apos;Xftp&apos;] ] &#125;"},{"title":"书单","date":"2019-07-25T09:37:08.380Z","updated":"2019-07-25T09:37:08.380Z","comments":false,"path":"books/index.html","permalink":"https://zhouxuan001.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-07-25T09:37:08.380Z","updated":"2019-07-25T09:37:08.380Z","comments":false,"path":"categories/index.html","permalink":"https://zhouxuan001.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-07-25T09:37:08.381Z","updated":"2019-07-25T09:37:08.381Z","comments":true,"path":"links/index.html","permalink":"https://zhouxuan001.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-25T09:37:08.381Z","updated":"2019-07-25T09:37:08.381Z","comments":false,"path":"tags/index.html","permalink":"https://zhouxuan001.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-07-25T09:37:08.381Z","updated":"2019-07-25T09:37:08.381Z","comments":false,"path":"repository/index.html","permalink":"https://zhouxuan001.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"今天创建了个人博客","slug":"今天创建了个人博客","date":"2019-07-25T09:37:08.379Z","updated":"2019-07-26T06:15:17.398Z","comments":true,"path":"2019/07/25/今天创建了个人博客/","link":"","permalink":"https://zhouxuan001.github.io/2019/07/25/今天创建了个人博客/","excerpt":"","text":"今天根据网上教程创建了属于自己的个人博客。 参考博客主题：https://blog.cofess.com/ 执行hexo -d命令时报错 出现类似以下的报错代码： 123warning: LF will be replaced by CRLF in 2015/12/05/hello-world/index.html.The file will have its original line endings in your working directory.... 此问题的解决方法是：修改根目录下的配置文件_config.yml，修改deploy节点。原因是没有配置正确的git仓库地址。 原来的配置为： 1234deploy: type: git repo: https://github.com/&#123;myname&#125;/&#123;myname&#125;.github.io.git branch: master 将其修改成如下： 1234deploy: type: git repo: https://&#123;myname&#125;：&#123;mypassword&#125;@github.com/&#123;myname&#125;/&#123;myname&#125;.github.io.git branch: master 如此，便解决了执行hexo -d命令时报错的问题。 从博客仓库地址 克隆项目文件(前提是已经搭建好自己的博客仓库了，把下面的 zhouxuan001 换成你自己的博客账号名) 1git clone git@github.com:zhouxuan001/zhouxuan001.github.io.git 克隆完分别执行以下代码安装npm依赖以及hexo部署发布插件 12$ npm install$ npm install hexo-deployer-git 在我们的博客文件仓库里有master分支和hexo分支，分别保存静态网页和源文件。 博客有进行修改变动以后： 执行git add . 、git commit -m “” 、 git push origin hexo来提交hexo网站源文件以供备份 依次执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d生成静态网页部署至Github上 每次写完博客后需要执行 $ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 命令上传静态网页变更到我们的Github上,这样我们的博客网站才能看得到我们最新的提交。 使用hexo的一些指令 1234567891011121314151617181920## 基本指令(将博客变更更新到个人github网站上)hexo s == hexo server #启动本地服务器预览hexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹,通过hexo g重新生成hexo g == hexo generate #生成静态网页(执行$ hexo g后会在站点根目录下生成public文件夹,hexo会将source目录下面的.md后缀的文件编译为.html后缀的文件,存放在/blog/public/路径下)hexo d #将本地数据部署到远端服务器(如github)## 提交整个网站源文件(将整个博客文件上传到git的网站源文件hexo分支上)git add . #添加修改代码到缓存（注意最后的\".\"前面有个空格git commit -m \"xxx\" #添加提交代码的备注（xxx为本次提交代码的备注）git push origin hexo #提交代码到指定分支（hexo为要提交代码的分支名称）## 其余指令：git branch #查看当前所属分支 master/hexogit branch -a #查看所有分支git checkout hexo #切换到某一分支(hexo填写要切换的分支名称）git remote -v # 查看当前的传输协议# =&gt; origin https://github.com/USERNAME/REPOSITORY.git (fetch)# =&gt; origin https://github.com/USERNAME/REPOSITORY.git (push)git remote set-url origin git@github.com:zhouxuan001/zhouxuan001.github.io.git # 修改 https 协议为 ssh 协议 如果出现 git push 报错如下： 1remote: Invalid username or password. fatal: Authentication failed for ... 这个情况一般是用户名和用户密码验证出错，我们查看一下目前使用的传输协议。 1$ git remote -v 如果显示不是使用https协议的话，我们可以修改传输协议，将我们github的用户名和密码配置进去，这样传输的时候便不会出错，也免去了每次传输都要输入密码的繁琐过程了。 查看github上项目的地址，点击当前项目右上角的Clone or download按钮，选择使用HTTPS协议，比如我的是 https://github.com/zhouxuan001/zhouxuan001.github.io.git。 在 github.com之前拼接我们的用户名username和密码password，如: username:password@ 拼接好以后使用以下命令，其中的 username 和 password 还有后面的博客地址中的zhouxuan001自己替换即可: 1$ git remote set-url origin https://username:password@github.com/zhouxuan001/zhouxuan001.github.io.git/ 再执行 git push 命令，大功告成！ 博客文件地址在 source/_posts/目录下。 网络博客主题模板： 更换模板方法(例：更换 grace 模板) 1$ git clone https://github.com/buhuo00/hexo-theme-grace themes/grace 再到根目录_config.yml配置文件中修改模板参数theme为 theme： grace 想要修改当前主题博客设置 请到到目录themes/pure/_config.yml文件中查看修改。(注:pure目录为自己当前的主题目录) 想要了解当前主题配置信息 请到themes/pure/README.cn.md文件中查看详细主题设置说明。(注:pure目录为自己当前的主题目录) END","categories":[],"tags":[]},{"title":"响应式开发(01)","slug":"响应式开发(01)","date":"2018-06-22T06:47:00.000Z","updated":"2019-07-25T09:37:08.379Z","comments":true,"path":"2018/06/22/响应式开发(01)/","link":"","permalink":"https://zhouxuan001.github.io/2018/06/22/响应式开发(01)/","excerpt":"","text":"响应式开发中获取用户设备信息的方法 var u = navigator.userAgent; 判断是否是Android设备 123if (u.indexOf(&quot;Android&quot;)&gt;-1||u.indexOf(&quot;Adr&quot;)&gt;-1) &#123; console.log(&quot;Android设备&quot;);&#125; 判断是否是iPhone设备 123if (u.indexOf(&quot;iPhone&quot;)&gt;-1) &#123; console.log(&quot;iPhone设备&quot;);&#125; 判断是否是iPad设备 123if (u.indexOf(&quot;iPad&quot;)&gt;-1) &#123; console.log(&quot;iPad设备&quot;);&#125; 剩下的就是PC设备了 123else&#123; console.log(&quot;PC设备&quot;);&#125; 1111 END","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhouxuan001.github.io/categories/前端开发/"}],"tags":[{"name":"响应式开发","slug":"响应式开发","permalink":"https://zhouxuan001.github.io/tags/响应式开发/"}]},{"title":"每日小记(01)","slug":"每日小记(01)","date":"2018-06-21T06:40:00.000Z","updated":"2019-07-26T06:15:39.629Z","comments":true,"path":"2018/06/21/每日小记(01)/","link":"","permalink":"https://zhouxuan001.github.io/2018/06/21/每日小记(01)/","excerpt":"","text":"开发一个转盘游戏时遇到的多终端兼容问题 我前端这边写了一个预加载执行函数,就是需要在页面加载完成之后执行这个里面的一系列操作,我在里面执行的是一个调用后端接口的函数,我需要调用这个接口来渲染页面数据。 但是在ios端运行时,执行调用后端接口时返回的状态一直是error,在安卓那边运行没有一点毛病。 实在理解不了,也想不出来是什么导致的。 后面觉得可能是ios中数据加载得比较慢的原因,于是使用一个倒计时来延时执行我们需要在页面完成之后再调用后端接口的函数,于是成功解决了这个问题。 其他问题 安卓端那边调用执行调用后端接口后,也出现过接口状态一直是error的情况。 原因是安卓APP端不支持ajax跨域请求,解决方法是让安卓那边加上支持跨域访问的代码。 END","categories":[{"name":"每日小记","slug":"每日小记","permalink":"https://zhouxuan001.github.io/categories/每日小记/"}],"tags":[{"name":"日常积累","slug":"日常积累","permalink":"https://zhouxuan001.github.io/tags/日常积累/"}]},{"title":"手把手教你搭建博客","slug":"手把手教你搭建博客","date":"2018-06-05T03:25:00.000Z","updated":"2019-07-25T09:37:08.379Z","comments":true,"path":"2018/06/05/手把手教你搭建博客/","link":"","permalink":"https://zhouxuan001.github.io/2018/06/05/手把手教你搭建博客/","excerpt":"","text":"前言：我今天新创建了属于自己的博客，还是很简单的，接下来让我来教大家怎么搭建博客吧！ END","categories":[{"name":"分享教程","slug":"分享教程","permalink":"https://zhouxuan001.github.io/categories/分享教程/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://zhouxuan001.github.io/tags/博客搭建/"}]},{"title":"微信小程序学习(01)","slug":"微信小程序学习计划-01","date":"2018-06-04T07:00:00.000Z","updated":"2019-07-25T09:37:08.379Z","comments":true,"path":"2018/06/04/微信小程序学习计划-01/","link":"","permalink":"https://zhouxuan001.github.io/2018/06/04/微信小程序学习计划-01/","excerpt":"","text":"待编辑 END","categories":[{"name":"学习计划","slug":"学习计划","permalink":"https://zhouxuan001.github.io/categories/学习计划/"}],"tags":[{"name":"微信小程序了解一哈","slug":"微信小程序了解一哈","permalink":"https://zhouxuan001.github.io/tags/微信小程序了解一哈/"}]},{"title":"CSS完成元素水平垂直居中","slug":"CSS水平垂直居中","date":"2018-05-31T07:39:00.000Z","updated":"2019-07-25T09:37:08.376Z","comments":true,"path":"2018/05/31/CSS水平垂直居中/","link":"","permalink":"https://zhouxuan001.github.io/2018/05/31/CSS水平垂直居中/","excerpt":"","text":"要求：子元素和父元素宽高不确定，需要设置子元素水平垂直居中，效果如下图： 这里提供几种简单的实现方法： 1.使用margin:auto属性实现【兼容IE7以上大部分浏览器】 首先这个元素和它的父元素都要设置定位，其中这个要水平垂直居中的元素需设置绝对定位absolute， 然后再给它设置样式{left: 0;right: 0;top: 0;bottom: 0;margin:auto;}。这样便可以实现元素在父容器里垂直居中显示了。 1234567891011121314151617181920&lt;style type=&quot;text/css&quot;&gt;.parent&#123; /*子元素和父元素宽高随意，都可以实现水平垂直居中，这里随便设置了一个宽高撑开盒子容器体积，方便查看效果*/ width: 600px; height: 500px; background: #222222; position: relative;&#125;.child&#123; width: 150px; height: 200px; background: goldenrod; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto;&#125;&lt;/style&gt; 2.使用transform属性实现【浏览器兼容性：Safari 3.1+、 Chrome 8+、Firefox 4+、Opera 10+、IE10+】 同上，设置好定位。然后添加样式{left: 50%;top: 50%;transform: translateX(-50%) translateY(-50%);}便好了。 其中的translateX(-50%)表示将此元素在X轴上向左移50%元素宽度的距离，同理translateY(-50%)将元素在Y轴上向上移50%元素高度的距离。 123456789101112131415161718&lt;style type=&quot;text/css&quot;&gt;.parent&#123; /*子元素和父元素宽高随意，都可以实现水平垂直居中，这里随便设置了一个宽高撑开盒子容器体积，方便查看效果*/ width: 600px; height: 500px; background: #222222; position: relative;&#125;.child&#123; width: 150px; height: 200px; background: goldenrod; position: absolute; left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%);&#125;&lt;/style&gt; 3.使用flex布局实现【浏览器兼容性：Safari 9+、 Chrome 29+、Firefox 28+、Opera 17+、IE10+】 首先给父元素设置flex布局{display: flex;}，然后父元素再设置align-items: center; 可以使其包裹的子元素在水平方向上水平居中排列， 再就是{justify-content: center;}属性规定了子元素在Y轴垂直方向上是居中排列。这样便实现了使用flex完成水平垂直居中的布局。 12345678910111213141516&lt;style type=&quot;text/css&quot;&gt;.parent&#123; /*子元素和父元素宽高随意，都可以实现水平垂直居中，这里随便设置了一个宽高撑开盒子容器体积，方便查看效果*/ width: 600px; height: 500px; background: #222222; display: flex; align-items: center; justify-content: center;&#125;.child&#123; width: 150px; height: 200px; background: goldenrod;&#125;&lt;/style&gt; END","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhouxuan001.github.io/categories/前端开发/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://zhouxuan001.github.io/tags/CSS/"}]},{"title":"使用jQuery中hover事件时遇到的一个小问题","slug":"hover事件遇到的小问题","date":"2018-05-26T08:52:00.000Z","updated":"2019-07-25T09:37:08.378Z","comments":true,"path":"2018/05/26/hover事件遇到的小问题/","link":"","permalink":"https://zhouxuan001.github.io/2018/05/26/hover事件遇到的小问题/","excerpt":"","text":"在jQuery中有一个hover()方法，它可以实现模拟css中：hover这个伪类的效果。 css伪类写法如下： 12345&lt;style type=&quot;text/css&quot;&gt; a:hover&#123; color: #ccc; &#125; &lt;/style&gt; jQuery中hover()方法如下 ： 123456&lt;script type=&quot;text/javascript&quot;&gt; $(&quot;a&quot;).hover(function()&#123; $(this).css(&#123;&quot;color&quot;:&quot;#ccc&quot;&#125;); console.log(1); &#125;) &lt;/script&gt; 如上所示，两种方法都可以完美的实现我们想要的效果。 但是，在这其中其实还隐藏着一个很难发现的bug。 如上，在hover()这个函数中，我们写了一个function方法， 但是我们不知道的是，我们写在这个function中的代码其实一直都会被重复执行两次。 它在鼠标移入的时候执行了一次，移出的时候又会执行一次(通过控制台查看可以看到我们代码中的console.log(1)中的1总共被输出了两次)。 而我们的本意是只想让它在鼠标移入的时候执行我们的代码，这与我们想要的效果不一样，那么这到底是什么原因导致的呢？ 搜索官方jQuery文档中hover()方法的说明我们就会发现，其实这是jQuery中hover()内置方法的问题。 jQuery中的hover()方法中一共封装有两个function函数，第一个是在移入时执行， 第二个是在移出时执行的，而当我们像上面一样只写了一个function函数的时候， 它就会默认这个function函数就是我们想让它在移入和移出时都被执行的函数， 也就相当于将这个函数执行了两遍。 当然，这个bug对于执行一些普通的效果是没什么影响的。 但是，当触及到跟时间有关的一些动画效果（例如：jQuery中的animate()函数）的时候， 就会出现问题。如下： 123456&lt;script type=&quot;text/javascript&quot;&gt; $(&quot;.box&quot;).hover(function()&#123; var this_h=$(this).height()+50; $(this).animate(&#123;&quot;height&quot;:this_h+&quot;px&quot;&#125;,1000);//每次高度在上一次数值的基础上用动画形式增加50 &#125;) &lt;/script&gt; 在上面的代码中，我们想要实现的效果是，当鼠标移入到class为box的这个元素的时候，我们先获取它的高度， 再将这个高度数值增加50赋予一个变量this_h， 然后用jQuery内置的animate()动画方法使这个元素1000毫秒内高度在原先的基础上增加50px。 之后其它每次移入时都将box这个元素的高度在原先的基础上增加50，下次再移入，再增加50的高度。 但是实际执行效果却是：一开始移入时，增加了50的高度，然后移出的时候，又增加了50高度，之后再次移入移出又陆续增加了100的高度。 那这样的话明显不对啊，那么，怎么解决这个问题呢？ 很简单，我们在hover事件中写入两个function函数就好了，其中第一个是我们要让它在移入的时候执行的效果， 第二个是让它在移出的时候执行的效果。像我们上面这种情况的话就可以在第二个函数里面什么都不写就好了，如下： 12345678&lt;script type=&quot;text/javascript&quot;&gt; $(&quot;.box&quot;).hover(function()&#123; var this_h=$(this).height()+50; $(this).animate(&#123;&quot;height&quot;:this_h+&quot;px&quot;&#125;,1000);//每次高度在上一次数值的基础上用动画形式增加50 &#125;,function()&#123; //我是第二个函数，什么都不写的时候，在移出的时候hover方法什么都不会执行。 &#125;) &lt;/script&gt; 当然，像这些效果的话，其实也有很多别的方法可以完成的， 比如我们也可以使用jQuery中的一些其他鼠标事件（例如：onmouseover、onmouseout、onmouseenter、onmouseleave等）来实现， 没必要一味地使用hover()来进行事件的编写。 END","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhouxuan001.github.io/categories/前端开发/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://zhouxuan001.github.io/tags/jQuery/"}]},{"title":"HTML里的数据存储分析","slug":"浅析HTML数据存储","date":"2018-05-25T05:53:52.000Z","updated":"2019-07-25T09:37:08.380Z","comments":true,"path":"2018/05/25/浅析HTML数据存储/","link":"","permalink":"https://zhouxuan001.github.io/2018/05/25/浅析HTML数据存储/","excerpt":"","text":"在前端开发工作中，常用的数据存储有三种，分别是cookie，localStorage和sessionStorage。 其中，cookie是存储在浏览器的一段文本，而localStorage和sessionStorage则是HTML5中所提供的本地存储。 那么，这几种数据存储方式之间有什么区别呢？让我们来了解一下。 1.cookie cookie是什么?cookie就是一段文本，它存储在客户端（通常来说是浏览器），目前为各大主流浏览器存储数据所用。 一般来说用其存储的数据有比如：名字、密码、日期...等信息。cookie存储的数据能在客户端上保留相当长的时间。 分析：用cookie存储的数据有大小限制，一般不可超过4096 个字节(4kb)，而且cookie的安全系数不高，有被篡改的风险。 不过其好处是几乎支持所有浏览器。 2.localStorage 和 sessionStorage localStorage和sessionStorage是HTML5 提供的两种在客户端存储数据的新方法。 主要目的是为了克服由cookie所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器。 同时它们能够存储的数据大小一般都是：5MB，可以在不影响网站性能的前提下将大量数据存储于本地。 localStorage是本地存储，它的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。除非主动删除数据，否则数据永远不会消失。 sessionStorage是会话存储，它是针对一个session(会话) 进行数据存储，它的生命周期仅在当前会话下有效。当用户关闭浏览器窗口后，数据将会被实时删除。 分析：localStorage和sessionStorage的存储空间更大； 数据不会传送到服务器，减少了客户端和服务器端的交互，节省了网络流量； 同时数据不发送到服务器端，不会担心数据被截获，安全性相对于cookie更高一些。 END","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhouxuan001.github.io/categories/前端开发/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://zhouxuan001.github.io/tags/JS/"}]},{"title":"JS监听中文输入","slug":"JS监听中文输入","date":"2018-05-25T03:28:47.000Z","updated":"2019-07-25T09:37:08.378Z","comments":true,"path":"2018/05/25/JS监听中文输入/","link":"","permalink":"https://zhouxuan001.github.io/2018/05/25/JS监听中文输入/","excerpt":"","text":"当时是在做 Wes Bos的 javascript30的一个 挑战。 在做第六个项目（根据输入框实时调用AJAX古诗匹配）时，当我们输入中文拼音，还在拼音字符状态未选择成中文时，一直在执行我编写的事件监听处理函数（当输入框里的值有变化时执行此函数， 调用AJAX在页面显示数据里包含这些字的古诗）。 而我想要的是在我们输入拼音未完成中文选择时，不让其执行我们的监听处理函数， 只有选择完中文后才去执行调用AJAX判断有没有包含输入的这些字的古诗。 古诗匹配项目效果图如下： 此问题解决方法如下： 1234567891011121314151617&lt;!--HTML代码片段--&gt;&lt;input type=&quot;text&quot; id=&quot;this_input&quot; placeholder=&quot;中文输入未完成时不执行事件&quot; /&gt; &lt;script src=&quot;http://code.jquery.com/jquery-1.8.3.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&apos;#this_input&apos;).on(&apos;input propertychange&apos;, function () &#123;//input propertychange 当输入框里的值有变化时执行此函数 if ($(this).prop(&apos;cnStart&apos;)) return;//如果正在执行中文输入时，此值为true，执行return=&gt;下面代码不执行 console.log(&apos;当前输入：&apos; + $(this).val()); //此处执行AJAX请求判断请求的数据中有没有包含输入的这些字的古诗 //如果有，就将所有包含这些字的诗排列出来 &#125;).on(&apos;compositionstart&apos;, function () &#123;//compositionstart 当输入框有非直接的文字输入时触发(如：输入拼音在待选状态时) $(this).prop(&apos;cnStart&apos;, true); console.log(&apos;正在中文输入&apos;);//将 cnStart 变为 true，此处执行完后会跳到 &#125;).on(&apos;compositionend&apos;, function () &#123;//compositionend 当输入框有直接的文字输入时触发(如：输入拼音后完成了中文选择时) $(this).prop(&apos;cnStart&apos;, false); console.log(&apos;完成中文输入&apos;); &#125;); &lt;/script&gt; 当我们开始进行input的输入改变了input框里的值时，js会监听到input propertychange事件， 执行判断(一开始时$(this).prop('cnStart')的值我们没有定义，为undefined， 在监听了compositionstart和compositionend事件后会相应变为true和false，非true时不会进行return)， 再输出文本，接下来此时会执行此函数中其它的一些操作(AJAX请求...)。 而当我们输入框输入的文字还在待选状态时（如：输入拼音未选择完成时），便会触发compositionstart事件， 此时我们通过jquery的prop()方法给这个input元素添加自定义属性（cnStart：自定义名称，表示中文输入开始）和值（true），执行输出语句。 此时执行完compositionstart事件后，因为输入框内文字有发生变化，会再去调用上面的input propertychange事件=>进行判断， 此时$(this).prop('cnStart')的值为true，会执行return语句，因此便会截断下面的所有操作，使其不会去执行。 而当我们输入框输入的文字不在待选状态后（如：输入拼音后完成了中文选择时），便会触发compositionend事件， 此时我们再将cnStart这个自定义属性设置为false，代表我们已经完成了中文输入，执行输出语句。此时执行完了compositionend事件， 同上会再去调用input propertychange事件=>进行判断，此时$(this).prop('cnStart')的值为false， 不会执行return语句，那么接下来才会顺利执行我们此函数中的一系列操作。 END","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhouxuan001.github.io/categories/前端开发/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://zhouxuan001.github.io/tags/JS/"}]},{"title":"关于一些动态创建的节点无法绑定事件的问题","slug":"JS动态节点绑定","date":"2018-05-25T02:02:09.000Z","updated":"2019-07-25T09:37:08.376Z","comments":true,"path":"2018/05/25/JS动态节点绑定/","link":"","permalink":"https://zhouxuan001.github.io/2018/05/25/JS动态节点绑定/","excerpt":"","text":"在我们HTML页面中有时候一些DOM元素节点（例如：一些页面加载的新闻公告列表[如下图]）是需要通过AJAX请求接口数据动态创建的， 而当我们想在JS中想为这些节点绑定事件（如：click,hover...等）时便会出现无法绑定的情况，使用window.onload方法在页面加载后才执行也不行。 解决办法： 使用JQ提供的.on()和.delegate()方法可以解决解决此问题，给动态加载的元素成功绑定上事件，但是在这两种方法的参数中一定得写上我们需要绑定事件的那个元素选择器。 如:$(\"#parent\").on(\"click\",\".list\",function(){ }) 和 $(\"#parent\").delegate(\"click\",\".list\",function(){ }) 。 这两种方法内的参数 .list 就是我们动态加载出来需要绑定事件的那个元素，前面的 #parent 是 .list 元素的父元素。 1234567891011121314151617//javascript 代码//.list为新闻里的每一条公告，是我们动态创建的;#parent是一个包裹着里的这一行行公告的一个div。//一般来说，我们绑定事件的写法都是用下面的第一和第二种写法。但是这种写法是绑定不上的。$(&apos;#parent .list&apos;).click(function()&#123;//1.直接使用click(fn)方法绑定不上 console.log($(this).html());&#125;)$(&apos;#parent .list&apos;).on(&apos;click&apos;,function()&#123;//2.使用on(&quot;click&quot;,fn)方法还是绑定不上 console.log($(this).html());&#125;)$(&apos;#parent&apos;).on(&apos;click&apos;,&apos;.list&apos;,function()&#123;//3.此种写法可以成功绑定 //使用on(&quot;click&quot;,&quot;...&quot;,fn),在on里面增加一个参数（需要绑定的那个节点），同时前面调用.on方法的元素改为该节点的父元素即：$(&apos;#parent&apos;) console.log($(this).html());&#125;)$(&apos;#parent&apos;).delegate(&apos;click&apos;,&apos;.list&apos;,function()&#123;//4.此种写法可以成功绑定 //使用delegate(&quot;click&quot;,&quot;...&quot;,fn),在delegate里面增加一个参数（需要绑定的那个节点），同时前面调用.delegate方法的元素改为该节点的父元素即：$(&apos;#parent&apos;) console.log($(this).html());&#125;) END","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://zhouxuan001.github.io/categories/前端开发/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://zhouxuan001.github.io/tags/JS/"}]}]}